<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="robots" content="noindex,nofollow">
    <title>ハシラガキ</title>
    <style>
        /* 基本設定 */
        @page { size: B5 portrait; margin: 0; }
        body { 
            margin: 0; background: #525659; 
            font-family: 'Yu Mincho', 'YuMincho', 'MS Mincho', 'Hiragino Mincho ProN', serif; 
            overflow-x: hidden;
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
        }
        .app-container { display: flex; height: 100vh; } 
        
        @media print {
            .editor-section { display: none !important; }
            .preview-section { padding: 0 !important; background: white !important; overflow: visible !important; }
            body { background: white; overflow: visible; }
            .page { margin: 0 !important; box-shadow: none !important; page-break-after: always; border: none !important; }
            .content-page::before { border-bottom: 1.5pt solid black !important; display: block !important; }
        }

        /* エディタ側レイアウト */
        .editor-section { width: 350px; display: flex; flex-direction: column; background: #fff; border-right: 1px solid #333; z-index: 100; }
        .toolbar { 
            padding: 20px 15px; background: #f8f9fa; border-bottom: 1px solid #ddd; 
            display: flex; flex-direction: column;
        }
        .app-name { font-size: 22px; font-weight: bold; color: #333; margin-bottom: 20px; text-align: center; font-family: 'Yu Mincho', serif; letter-spacing: 0.1em; }
        
        .btn {
            display: block; width: 100%; padding: 12px; margin-bottom: 8px; 
            border-radius: 4px; cursor: pointer; text-align: center; 
            font-weight: bold; border: none; font-size: 14px; box-sizing: border-box; text-decoration: none;
            transition: opacity 0.2s;
        }
        .btn:hover { opacity: 0.8; }
        
        .file-label { background: #28a745; color: white; }
        .pdf-button { background: #007bff; color: white; }
        .help-button-style { background: #6c757d; color: white; }
        
        #save-status { font-size: 11px; color: #28a745; text-align: right; padding: 5px 0; height: 15px; font-weight: bold; }
        #editor { flex: 1; padding: 15px; font-size: 14px; border: none; border-top: 1px solid #ddd; outline: none; resize: none; line-height: 1.5; background: #fafafa; }

        /* プレビュー側レイアウト */
        .preview-section { flex: 1; overflow-y: auto; padding: 40px; background: #525659; display: flex; flex-direction: column; align-items: center; }
        .page { background: white; margin-bottom: 40px; width: 182mm; height: 257mm; box-sizing: border-box; writing-mode: vertical-rl; position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.4); flex-shrink: 0; }
        .content-page { padding-top: 85mm; padding-bottom: 15mm; padding-right: 15mm; padding-left: 15mm; }
        .content-page::before { content: ""; position: absolute; top: 80mm; right: 10mm; left: 10mm; height: 0; border-bottom: 1.5pt solid black; z-index: 20; pointer-events: none; }
        .title-page { display: flex !important; justify-content: center !important; align-items: center !important; }
        .title-text { font-size: 28pt; font-weight: bold; letter-spacing: 0.5em; writing-mode: vertical-rl; }
        .line-container { position: absolute; top: 85mm; height: 152mm; width: 11.5pt; }
        .line { height: 100%; font-size: 11.5pt; line-height: 1.2; letter-spacing: 0.05em; white-space: pre-wrap; line-break: strict; }
        .line-hashira { border: 1.5px solid #000; padding: 9mm 0.4em 0.3em 0.4em; width: 2.7em; height: 172mm !important; background: white; position: absolute; top: -20mm; left: 50%; transform: translateX(-50%); box-sizing: border-box; z-index: 10; display: block; }
        .tcy { text-combine-upright: all; -webkit-text-combine: horizontal; display: inline-block; }
        .page-footer { position: absolute; bottom: 8mm; left: 0; right: 0; writing-mode: horizontal-tb; font-size: 10pt; text-align: center; }

        /* ヘルプ画面 */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 999; }
        #help-modal {
            display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; padding: 30px; border-radius: 8px; box-shadow: 0 0 30px rgba(0,0,0,0.3);
            z-index: 1000; width: 85%; max-width: 500px; writing-mode: horizontal-tb;
        }
        #help-modal h3 { margin-top: 0; border-bottom: 2px solid #333; padding-bottom: 10px; }
        #help-modal h4 { margin: 15px 0 5px 0; color: #007bff; }
        #help-modal ul { padding-left: 20px; margin-bottom: 10px; }
        #help-modal li { margin-bottom: 5px; line-height: 1.4; }
    </style>
</head>
<body>

<div class="modal-overlay" id="overlay" onclick="toggleHelp()"></div>
<div id="help-modal">
    <h3>『ハシラガキ』の使い方</h3>
    <h4>・操作方法</h4>
    <ul>
        <li>「テキストを読み込む」を押す</li>
        <li>文章を訂正したい場合は左側のエリアで書き換える</li>
        <li>「PDFとして保存・印刷」を押す</li>
    </ul>
    <h4>・テキストファイルの書き方</h4>
    <ul>
        <li><b>タイトル:</b> 行頭に「#」をつける</li>
        <li><b>シーン（柱）:</b> 行頭に「○」をつける</li>
        <li><b>セリフ:</b> 「」で囲む</li>
        <li><b>ト書き:</b> それ以外の行（自動で6文字下がります）</li>
    </ul>
    <button class="btn help-button-style" onclick="toggleHelp()" style="margin-top: 20px;">閉じる</button>
</div>

<div class="app-container" id="main-app">
    <div class="editor-section">
        <div class="toolbar">
            <div class="app-name">ハシラガキ</div>
            <label class="btn file-label" for="file-input">テキストを読み込む</label>
            <input type="file" id="file-input" style="display:none" accept=".txt">
            
            <button class="btn pdf-button" id="print-btn">PDFとして保存・印刷</button>
            
            <button class="btn help-button-style" onclick="toggleHelp()">ヘルプ</button>
            <div id="save-status"></div>
        </div>
        <textarea id="editor" placeholder="#タイトルを入力"></textarea>
    </div>
    <div id="preview-area" class="preview-section"></div>
</div>

<script>
    const editor = document.getElementById('editor');
    const previewArea = document.getElementById('preview-area');
    const saveStatus = document.getElementById('save-status');
    const printBtn = document.getElementById('print-btn');

    const SAMPLE_TEXT = `#タイトル\n○ある場所\n　　ここには「ト書き」を書きます。\n\n名前「ここにはセリフを書きます」`;

    window.onload = () => {
        // localStorage から sessionStorage に変更
        const saved = sessionStorage.getItem('hashiragaki_data');
        editor.value = saved ? saved : SAMPLE_TEXT;
        render();
    };

    function showNotify(message) {
        saveStatus.innerText = message;
        setTimeout(() => {
            if (saveStatus.innerText === message) saveStatus.innerText = '';
        }, 4000);
    }

    printBtn.onclick = () => {
        window.print();
        setTimeout(() => { if (saveStatus.innerText === '') showNotify('PDF操作完了'); }, 1000);
    };

    window.onafterprint = () => { showNotify('PDF操作完了'); };

    window.matchMedia('print').addListener((mql) => {
        if (!mql.matches) showNotify('PDF操作完了');
    });

    function toggleHelp() {
        const m = document.getElementById('help-modal');
        const o = document.getElementById('overlay');
        const isShow = m.style.display === 'block';
        m.style.display = isShow ? 'none' : 'block';
        o.style.display = isShow ? 'none' : 'block';
    }

    function formatName(name) {
        name = name.trim();
        if (name.length === 1) return "　" + name + "　　";
        if (name.length === 2) return name[0] + "　" + name[1] + "　";
        if (name.length === 3) return name + "　";
        if (name.length >= 4) return name.substring(0, 4);
        return name;
    }

    function saveLocal() {
        // localStorage から sessionStorage に変更
        sessionStorage.setItem('hashiragaki_data', editor.value);
        saveStatus.innerText = '一時保存完了';
        setTimeout(() => { if(saveStatus.innerText === '一時保存完了') saveStatus.innerText = ''; }, 2000);
    }

    function splitWithKinsoku(fullText, maxChars, indentSize) {
        if (fullText === '') return [''];
        let lines = [];
        let remaining = fullText;
        const indentStr = "　".repeat(indentSize);
        while (remaining.length > 0) {
            let limit = maxChars - indentSize; 
            let sliceIdx = limit;
            if (remaining.length > sliceIdx) {
                const kHead = "、。．，：；！？・）」』｝】〉》〕ぁぃぅぇぉっゃゅょゎー～";
                const kTail = "（「『｛【〈《〔";
                if (kHead.includes(remaining[sliceIdx])) sliceIdx--;
                else if (kTail.includes(remaining[sliceIdx - 1])) sliceIdx--;
            }
            lines.push(indentStr + remaining.substring(0, sliceIdx));
            remaining = remaining.substring(sliceIdx);
        }
        return lines;
    }

    function render() {
        const text = editor.value;
        const maxLines = 19; 
        previewArea.innerHTML = '';
        if(!text) return;

        const rawLines = text.split(/\r?\n/);
        let title = "無題";
        let processedLines = [];
        let sceneCount = 0; 

        rawLines.forEach(line => {
            let clean = line.trim();
            if (clean.match(/^[#＃]/)) { title = clean.replace(/[#＃]/g, ''); return; }
            if (clean === '') { processedLines.push({ text: '', type: "normal" }); return; }
            clean = clean.replace(/…/g, '︙');
            if (clean.startsWith('○')) {
                sceneCount++;
                processedLines.push({ num: sceneCount, text: clean.substring(1), type: "hashira" });
            } else if (clean.includes('「')) {
                const bracketIdx = clean.indexOf('「');
                const rawName = clean.substring(0, bracketIdx);
                const dialogue = clean.substring(bracketIdx);
                const formattedName = formatName(rawName);
                const segments = splitWithKinsoku(formattedName + dialogue, 30, 0); 
                segments.forEach((s, idx) => {
                    let text = (idx > 0) ? "　".repeat(5) + s.trim() : s;
                    processedLines.push({ text: text, type: "normal" });
                });
            } else {
                const segments = splitWithKinsoku(clean, 30, 6);
                segments.forEach(s => processedLines.push({ text: s, type: "normal" }));
            }
        });

        let pages = [];
        let current = [];
        for (let i = 0; i < processedLines.length; i++) {
            const line = processedLines[i];
            if (line.type === "hashira") {
                const remainingSpace = maxLines - current.length;
                if (remainingSpace <= 2) {
                    pages.push(current);
                    current = [];
                }
            }
            current.push(line);
            if (current.length === maxLines) {
                pages.push(current);
                current = [];
            }
        }
        if (current.length > 0) pages.push(current);

        const tp = document.createElement('div');
        tp.className = 'page title-page';
        tp.innerHTML = `<div class=\"title-text\">${title}</div>`;
        previewArea.appendChild(tp);

        pages.forEach((pageLines, pIdx) => {
            const pageDiv = document.createElement('div');
            pageDiv.className = 'page content-page';
            const rightMargin = 15;
            const leftMargin = 15;
            const step = (182 - rightMargin - leftMargin) / (maxLines - 1);

            pageLines.forEach((lineObj, lIdx) => {
                const container = document.createElement('div');
                container.className = 'line-container';
                container.style.right = (rightMargin + (lIdx * step)) + "mm";
                if (lineObj.type === "hashira") {
                    const hashiraEl = document.createElement('div');
                    hashiraEl.className = 'line-hashira';
                    hashiraEl.innerHTML = `<span class=\"tcy\">${lineObj.num}</span>　${lineObj.text}`;
                    container.appendChild(hashiraEl);
                } else {
                    const lineEl = document.createElement('div');
                    lineEl.className = 'line';
                    lineEl.innerText = lineObj.text === '' ? '　' : lineObj.text;
                    container.appendChild(lineEl);
                }
                pageDiv.appendChild(container);
            });
            pageDiv.innerHTML += `<div class=\"page-footer\">${pIdx + 1}</div>`;
            previewArea.appendChild(pageDiv);
        });
    }

    document.getElementById('file-input').onchange = (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (ev) => {
            const rawText = ev.target.result;
            const lines = rawText.split(/\r?\n/);
            let processedLines = [];
            for (let i = 0; i < lines.length; i++) {
                const currentLine = lines[i];
                const cleanLine = currentLine.trim();
                if (cleanLine.startsWith('○')) {
                    if (processedLines.length > 0 && processedLines[processedLines.length - 1].trim() !== "") {
                        processedLines.push("");
                    }
                    processedLines.push(currentLine);
                    if (i + 1 < lines.length) {
                        if (lines[i + 1].trim() !== "") processedLines.push("");
                    } else {
                        processedLines.push("");
                    }
                } else {
                    processedLines.push(currentLine);
                }
            }
            editor.value = processedLines.join('\n');
            render(); 
            saveLocal(); 
        };
        reader.readAsText(file, 'UTF-8');
    };
    editor.oninput = () => { render(); saveLocal(); };
</script>
</body>
</html>